<html>
<head>
<title>Artichoke FTW</title>
<link rel="stylesheet" type="text/css" href="css/style.css" />
</head>
<body>
<div id='wrapper'>
  <h1>Artichoke</h1>
  <h2>About</h2>
  <p>
    Artichoke is a layered framework for creating other frameworks. It's just like connect for Nodejs, but for Go. This isn't meant for writing applications, but for writing frameworks for applications.
  </p>

  <h2>Middleware</h2>
  <p>
    Artichoke has the bare minimum to get you started. For now, this is the middleware bundled with Artichoke:
  </p>

  <ul>
    <li>Static- static file handler</li>
    <li>Router- simple resource router</li>
  </ul>

  <p>
  Look at the middleware in src/middleware for examples on how to build custom middleware.
  </p>

  <h2>Example</h2>
  <p>
    This is the code for this example:
  </p>

  <code>
    <pre>
package main

import (
	"artichoke"
	"net/http"
	"fmt"
)

func handler(w http.ResponseWriter, r *http.Request, m artichoke.Data) bool {
	params := m["params"].(map[string]string)
	w.Write([]byte("Hello " + params["first"] + " " + params["last"]));
	w.Write([]byte(""))
	return true;
}

func genRoutes() []artichoke.Route {
	ret := []artichoke.Route{
		artichoke.Route{
			Method: "GET",
			Pattern: "/greet/:first/:last",
			Handler: handler,
		},
		artichoke.Route{
			Method: "GET",
			Pattern: "/greet/:first",
			Handler: handler,
		},
	}

	return ret
}

func logger(w http.ResponseWriter, r *http.Request, m artichoke.Data) bool {
	fmt.Println("Method: " + r.Method)
	fmt.Println("URL: " + r.URL.Raw)
	fmt.Println("")
	return false
}

func main() {
	server := artichoke.New(nil, logger, artichoke.Router(genRoutes()), artichoke.Static("./public"))
	server.RunLocal(3345)
}
    </pre>
  </code>

  <p>
    <span>logger</span> is a custom middleware, and the app uses the provided <span>Router</span> to route simple requests and <span>Static</span> middleware to serve static files. If router middleware doesn't find a route, then it returns false, and <span>artichoke</span> continues down the stack. If route does find a match, then it returns true stop execution of the stack. The custom <span>logger</span> always returns false, so it never ends the request, but it does log useful data to the console.
  </p>

  <p>
    As you can see, the construction is quite simple. If this webapp was more complicated, then the problem could be broken down to a series of middleware to do most of the hard work (such as authentication, database queries, templating, etc).
  </p>
</div>
</body>
</html>
