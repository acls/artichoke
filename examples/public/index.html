<html>
<head>
<title>Artichoke FTW</title>
<link rel="stylesheet" type="text/css" href="css/style.css" />
</head>
<body>
<div id='wrapper'>
  <h1>Artichoke</h1>
  <h2>About</h2>
  <p>
    Artichoke is a layered framework for creating other frameworks. It's just like connect for Nodejs, but for Go. This isn't meant for writing applications, but for writing frameworks for applications.
  </p>

  <h2>Middleware</h2>
  <p>
    Artichoke has the bare minimum to get you started. For now, this is the middleware bundled with Artichoke:
  </p>

  <ul>
    <li>Static- static file handler</li>
    <li>Router- simple resource router</li>
  </ul>

  <p>
  Look at the middleware in src/middleware for examples on how to build custom middleware.
  </p>

  <h3>Static</h3>
  <p>
    <span>Static</span> is a simple static file handler. It takes a single parameter, the path to the root directory to serve files from.
  </p>

  <h3>Router</h3>
  <p>
    <span>Router</span> is based on Sinatra for Ruby.
  </p>

  <p>
    If something of the form of <span>:identifier</span> is present, it is interpreted as an identifier. Identifiers can be anything accepted by Go as an identifier. The last parameter passed to a Middleware will have a key "params", and a value for every identifier found.
  </p>
  <p>
    If there is a <span>?</span> present, it treats the previous character or variable as optional. In the example code below, we have <span>/greet/:first/?:last?</span>. This will match any string starting with <span>/greet/</span>, followed by some URL segment, followed by an optional <span>/</span> and an optional URL segment. They will be assigned the names first and last respectively.
  </p>

  <h2>Example</h2>
  <p>
    This is the code for this example:
  </p>

  <code>
    <pre>
package main

import (
	"artichoke"
	"net/http"
	"fmt"
)

func handler(w http.ResponseWriter, r *http.Request, m artichoke.Data) bool {
	params := m["params"].(map[string]string)
	w.Write([]byte("Hello " + params["first"] + " " + params["last"]));
	w.Write([]byte(""))
	return true;
}

func genRoutes() []artichoke.Route {
	ret := []artichoke.Route{
		artichoke.Route{
			Method: "GET",
			Pattern: "/greet/:first/?:last?",
			Handler: handler,
		},
	}

	return ret
}

func logger(w http.ResponseWriter, r *http.Request, m artichoke.Data) bool {
	fmt.Println("Method: " + r.Method)
	fmt.Println("URL: " + r.URL.Raw)
	fmt.Println("")
	return false
}

func main() {
	server := artichoke.New(nil, logger, artichoke.Router(genRoutes()), artichoke.Static("./public"))
	server.RunLocal(3345)
}
    </pre>
  </code>

  <p>
    <span>logger</span> is a custom middleware. On each request, it simply logs the method and URL in the request and returns false to signify that it hasn't ended the response.
  </p>
  <p>
    The app also uses two of the provided middleware, <span>Router</span> and <span>Static</span>. If router middleware doesn't find a route, then it returns false, and <span>artichoke</span> continues down the stack. If route does find a match, then it returns true stop execution of the stack. <span>Static</span> always ends the response, so it is at the end of the stack.
  </p>

  <p>
    As you can see, the construction is quite simple. If this webapp was more complicated, then the problem could be broken down to a series of middleware to do most of the hard work (such as authentication, database queries, templating, etc).
  </p>
</div>
</body>
</html>
